{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Python Programming Language One of the things I wish to see more when writing Python code is better ways to learn and write clean code the hard way. Although \"Learn Python the Hard Way\" has been divisive in the community, I was one of the people who was undoubtedly influenced when learning the language as an additional programming language. When going through the Rust Book , it suddenly showed me how I would have liked to learn style and approach. This book is an attempt to capture the essence of both \"Learn the Hard Way\" and the Rust book style of a python book. Of course this book will offer an opinionated take - though my hope is that the reader will gain new perspective in writing Python code, and serve as a reference to how I like to think about my own toolchain and thought process. Furthermore part of my journey within this book is to help bridge my Python and Rust knowledge, to discuss the differences and nuances and also perhaps help Python programmers migrate to Rust themselves. Thank you so much for reading.","title":"Python Book"},{"location":"#the-python-programming-language","text":"One of the things I wish to see more when writing Python code is better ways to learn and write clean code the hard way. Although \"Learn Python the Hard Way\" has been divisive in the community, I was one of the people who was undoubtedly influenced when learning the language as an additional programming language. When going through the Rust Book , it suddenly showed me how I would have liked to learn style and approach. This book is an attempt to capture the essence of both \"Learn the Hard Way\" and the Rust book style of a python book. Of course this book will offer an opinionated take - though my hope is that the reader will gain new perspective in writing Python code, and serve as a reference to how I like to think about my own toolchain and thought process. Furthermore part of my journey within this book is to help bridge my Python and Rust knowledge, to discuss the differences and nuances and also perhaps help Python programmers migrate to Rust themselves. Thank you so much for reading.","title":"The Python Programming Language"},{"location":"introduction/","text":"Introduction Welcome to my Python Book , which is an introductory book about Python 3. We hope that by reading this book, it helps you write cleaner, more reliable Python code, and enable you to bridge Python to Rust. Who This Book Is For This book assumes that you have written some code in another programming language. It is most definitely not designed as a beginner book in programming. If you are starting your programming journey, there are probably better books to consider. How to Use This Book In general we assume the book is read sequentially, but of course feel free to skip ahead, and jump back - whatever works for you!","title":"Introduction"},{"location":"introduction/#introduction","text":"Welcome to my Python Book , which is an introductory book about Python 3. We hope that by reading this book, it helps you write cleaner, more reliable Python code, and enable you to bridge Python to Rust.","title":"Introduction"},{"location":"introduction/#who-this-book-is-for","text":"This book assumes that you have written some code in another programming language. It is most definitely not designed as a beginner book in programming. If you are starting your programming journey, there are probably better books to consider.","title":"Who This Book Is For"},{"location":"introduction/#how-to-use-this-book","text":"In general we assume the book is read sequentially, but of course feel free to skip ahead, and jump back - whatever works for you!","title":"How to Use This Book"},{"location":"1.%20Getting%20Started/01-installation/","text":"Installation The first step for working with Python is installing Python itself. The easiest way is to install Python via command line tools. Command Line Notation In this chapter and throughout the book, we\u2019ll show some commands used in the terminal. Lines that you should enter in a terminal all start with $ . You don\u2019t need to type in the $ character; it indicates the start of each command. Lines that don\u2019t start with $ typically show the output of the previous command. Additionally, PowerShell-specific examples will use > rather than $ . Installing Python on macOS If you are using macOS and you have brew installed, then you can enter the following command: $ brew install python","title":"Installation"},{"location":"1.%20Getting%20Started/01-installation/#installation","text":"The first step for working with Python is installing Python itself. The easiest way is to install Python via command line tools.","title":"Installation"},{"location":"1.%20Getting%20Started/01-installation/#command-line-notation","text":"In this chapter and throughout the book, we\u2019ll show some commands used in the terminal. Lines that you should enter in a terminal all start with $ . You don\u2019t need to type in the $ character; it indicates the start of each command. Lines that don\u2019t start with $ typically show the output of the previous command. Additionally, PowerShell-specific examples will use > rather than $ .","title":"Command Line Notation"},{"location":"1.%20Getting%20Started/01-installation/#installing-python-on-macos","text":"If you are using macOS and you have brew installed, then you can enter the following command: $ brew install python","title":"Installing Python on macOS"},{"location":"1.%20Getting%20Started/02-hello-world/","text":"Hello, World! Now that you've installed Python, let's write our first Python program; printing Hello, World! to the screen. Note: in this book we assume familiarity with command line. We make no assumption on the tooling, or how you may edit your code. There are many great integrated development environments (IDE) that have excellent Python support. Creating a Project Directory Let's start by making a directory to store our Python code. It doesn't really matter where Python code resides, but for working through this book, we recommend making a projects directory in your home directory and keeping all your projects there. Open a terminal and enter the following commands to make a projects directory and a directory for the \u201cHello, world!\u201d project within the projects directory. For Linux, macOS, and PowerShell on Windows, enter this: $ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world For Windows CMD, enter this: > mkdir \"%USERPROFILE%\\projects\" > cd /d \"%USERPROFILE%\\projects\" > mkdir hello_world > cd hello_world Writing and Running a Python Program Now, let's make a source file and call it main.py . Python files end with the extension .py . It is convention if you use more than one word in the filename, then an underscore is used to separate them. For example, it is preferable to use hello_world.py rather than helloworld.py . Open main.py file you just created and enter the following code Filename: main.py print ( \"Hello, world!\" ) Save the file and go back to your terminal to run the file: $ python main.py Hello, world! Regardless of your operating system, the string Hello, world! should print to the terminal. If you got this to print, then you've officially written your first Python program!","title":"Hello, World!"},{"location":"1.%20Getting%20Started/02-hello-world/#hello-world","text":"Now that you've installed Python, let's write our first Python program; printing Hello, World! to the screen. Note: in this book we assume familiarity with command line. We make no assumption on the tooling, or how you may edit your code. There are many great integrated development environments (IDE) that have excellent Python support.","title":"Hello, World!"},{"location":"1.%20Getting%20Started/02-hello-world/#creating-a-project-directory","text":"Let's start by making a directory to store our Python code. It doesn't really matter where Python code resides, but for working through this book, we recommend making a projects directory in your home directory and keeping all your projects there. Open a terminal and enter the following commands to make a projects directory and a directory for the \u201cHello, world!\u201d project within the projects directory. For Linux, macOS, and PowerShell on Windows, enter this: $ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world For Windows CMD, enter this: > mkdir \"%USERPROFILE%\\projects\" > cd /d \"%USERPROFILE%\\projects\" > mkdir hello_world > cd hello_world","title":"Creating a Project Directory"},{"location":"1.%20Getting%20Started/02-hello-world/#writing-and-running-a-python-program","text":"Now, let's make a source file and call it main.py . Python files end with the extension .py . It is convention if you use more than one word in the filename, then an underscore is used to separate them. For example, it is preferable to use hello_world.py rather than helloworld.py . Open main.py file you just created and enter the following code Filename: main.py print ( \"Hello, world!\" ) Save the file and go back to your terminal to run the file: $ python main.py Hello, world! Regardless of your operating system, the string Hello, world! should print to the terminal. If you got this to print, then you've officially written your first Python program!","title":"Writing and Running a Python Program"},{"location":"1.%20Getting%20Started/03-hello-pip/","text":"Hello, Poetry! Writing clean Python code isn't just about writing Python scripts. At some point your code needs to be distributed and deployed. Often we need to describe and manage the libraries which our code requires. Unlike Rust, there isn't an idiomatic pattern like cargo to construct packages. In this book, we use poetry as an opinionated way to construct packages, as it is an approach inspired by cargo . First check if pip is installed through $ pip --version If you see a version number, then that's it! Otherwise you'll need to install pip depending on how you have installed python. Now you can install poetry as follows $ pip install poetry Creating a Project with Poetry We can create a project with poetry . $ poetry new hello_poetry $ cd hello_poetry Inside this directory you can see all the files required to build a python package. First lets have a look at hello_poetry/__init__.py Filename: hello_poetry/__init__.py __version__ = '0.1.0' Poetry has generated a package for us, it is up to us to add an some code. To accomplish this create the file hello_poetry/__main__.py Filename: hello_poetry/__main__.py print ( \"Hello, world!\" ) Now we can run this via poetry run python -m hello_poetry which results in this: $ poetry run python -m hello_poetry Hello, world! What happend here? Poetry under the hood does several things: It creates a virtual environment based on our package definition. It starts up python and runs the module as a script via the -m flag. There a few additional command line features in poetry including poetry install , poetry build , and extensions to poetry run which we can configure as part of our pyproject.toml . Summary In this chapter we've: Installed Python Written a \"Hello, World!\" program using python directly Created a new python package using the conventions of poetry Now we can start writing a more substantial program to get used to reading Python code.","title":"Hello, Poetry!"},{"location":"1.%20Getting%20Started/03-hello-pip/#hello-poetry","text":"Writing clean Python code isn't just about writing Python scripts. At some point your code needs to be distributed and deployed. Often we need to describe and manage the libraries which our code requires. Unlike Rust, there isn't an idiomatic pattern like cargo to construct packages. In this book, we use poetry as an opinionated way to construct packages, as it is an approach inspired by cargo . First check if pip is installed through $ pip --version If you see a version number, then that's it! Otherwise you'll need to install pip depending on how you have installed python. Now you can install poetry as follows $ pip install poetry","title":"Hello, Poetry!"},{"location":"1.%20Getting%20Started/03-hello-pip/#creating-a-project-with-poetry","text":"We can create a project with poetry . $ poetry new hello_poetry $ cd hello_poetry Inside this directory you can see all the files required to build a python package. First lets have a look at hello_poetry/__init__.py Filename: hello_poetry/__init__.py __version__ = '0.1.0' Poetry has generated a package for us, it is up to us to add an some code. To accomplish this create the file hello_poetry/__main__.py Filename: hello_poetry/__main__.py print ( \"Hello, world!\" ) Now we can run this via poetry run python -m hello_poetry which results in this: $ poetry run python -m hello_poetry Hello, world! What happend here? Poetry under the hood does several things: It creates a virtual environment based on our package definition. It starts up python and runs the module as a script via the -m flag. There a few additional command line features in poetry including poetry install , poetry build , and extensions to poetry run which we can configure as part of our pyproject.toml .","title":"Creating a Project with Poetry"},{"location":"1.%20Getting%20Started/03-hello-pip/#summary","text":"In this chapter we've: Installed Python Written a \"Hello, World!\" program using python directly Created a new python package using the conventions of poetry Now we can start writing a more substantial program to get used to reading Python code.","title":"Summary"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/","text":"Let's drive right into it and begin by building a guessing game. We\u2019ll implement a classic beginner programming problem: a guessing game. Here\u2019s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit. Setting Up a New Project To setup a new project we'll navigate to the projects directory and make a new project using Poetry like so: $ poetry new guessing_game $ cd guessing_game $ echo 'print(\"Hello, world!\")' > guessing_game/__main__.py Just like in Chapter 1, we'll start by printing \"Hello, world!\" by adding a new file guessing_game/__main__.py . Filename: guessing_game/__main__.py print ( \"Hello, world!\" ) Now we can run this via poetry run as a module: $ poetry run python -m guessing_game Hello, world! We can use this rapidly iterate on a project. Let's modify guessing_game/__main__.py some more. Processing a guess The first thing we need to achieve in our game is to ask for user input and process that input. To start, we'll allow the player to input a guess. Filename: guessing_game/__main__.py print ( \"Guess the number!\" ) guess = input ( \"Please input your guess: \" ) print ( f \"You guessed: { guess } \" ) We now introduce the input function which enables input. Notice that the resulting variable stored in guess is now a string . When printing out strings in python, you can make use of f-strings, which makes it easier for format strings. Storing Values with Variables Similar to many other dynamic programming languages, python does not distinguish between mutable and immutable types. For example: guess = \"hello\" guess = 10 Is entirely allowable code, even though not only did the variable change, but the type changed as well! We'll go through validation strategies in a later chapter, for now, we can simply try parsing the output. Filename: guessing_game/__main__.py print ( \"Guess the number!\" ) guess = int ( input ( \"Please input your guess: \" )) print ( f \"You guessed: { guess } \" ) This will work as intended for integer inputs $ poetry run python -m guessing_game Guess the number! Please input your guess: 10 You guessed: 10 Now if you input anything that isn't an integer it will raise a ValueError : $ poetry run python -m guessing_game Guess the number! Please input your guess: not a number Please input your guess: not a number Traceback (most recent call last): File \"/bin/python/runpy.py\", line 193, in _run_module_as_main \"__main__\", mod_spec) File \"/bin/python/runpy.py\", line 85, in _run_code exec(code, run_globals) File \"file:///projects/guessing_game/guessing_game/__main__.py\", line 2, in <module> guess = int(input(\"Please input your guess: \")) ValueError: invalid literal for int() with base 10: 'not a number' Generating a Secret Number The next step is to generate a secret number to guess. This number needs to be randomly generated everytime the program is run, so we'll use a random number generator between 1 and 100. As the Python standard libraries include random , we can use this to generate random numbers. Filename: guessing_game/__main__.py import random print ( \"Guess the number!\" ) secret_number = random . randint ( 1 , 100 ) print ( f \"The secret number is: { secret_number } \" ) guess = int ( input ( \"Please input your guess: \" )) print ( f \"You guessed: { guess } \" ) First we add the line: import random . This enables the random module to be used within our project. We then can add the code to generate the number, which is conveniently proivided as random.randint(1, 100) , alternatively we could use random.choice(range(1, 101)) to request a number between 1 and 100. Of course, its not feasible to just try \"guessing\" what methods or functions to use from a python module. Within Python, by convention docstrings are typically used. To view docstrings for rand for example, you can try entering print(rand.__doc__) to read the package level documentation for rand and print(random.randint.__doc__) for the documentation for the randint function. For now we are also printing the secret number for testing purposes - in the final version we would remove it. Otherwise it would not be much of a game! Let's try running the programming a few times. $ poetry run python -m guessing_game Guess the number! The secret number is: 64 Please input your guess: 4 You guessed: 4 $ poetry run python -m guessing_game Guess the number! The secret number is: 49 Please input your guess: 10 You guessed: 10 You should get different random numbers which are between 1 and 100. Comparing the Guess to the Secret Number To compare guesses in Python, we will make use of if and else statements. Filename: guessing_game/__main__.py import random print ( \"Guess the number!\" ) secret_number = random . randint ( 1 , 100 ) guess = int ( input ( \"Please input your guess: \" )) if guess < secret_number : print ( \"Too small!\" ) elif guess > secret_number : print ( \"Too big!\" ) else : print ( \"Just right!\" ) Note: at this point in time you would realise whitespace is special in Python! Rather than using curly braces, Python uses whitespace to define the \"scope\" for control flow operations. In Python 3.X, there isn't an inbuilt cmp operator where this can be achieved through pattern matching without additional overhead. Rather than having one guess, we can include a while loop as well Filename: guessing_game/__main__.py import random print ( \"Guess the number!\" ) secret_number = random . randint ( 1 , 100 ) while ( guess := int ( input ( \"Please input your guess: \" ))) != secret_number : if guess < secret_number : print ( \"Too small!\" ) elif guess > secret_number : print ( \"Too big!\" ) else : print ( \"Just right!\" ) This is an example of the walrus operator := , if you are running a version lower than Python 3.8, you may need to split up the code to resemble the below: guess = int ( input ( \"Please input your guess: \" )) while True : # add a way for comparison and guess to be updated. We can also ensure Poetry picks up on these nuances, to explore this further, we should first change the expected Python version to reflect this: Filename: pyproject.toml [tool.poetry.dependencies] python = \"^3.8\" This would indicate at the version of Python is at least Python 3.8, then we should update Poetry so it is aware that our configuration has changed via poetry lock . Then your output should resemble the below: $ poetry lock Updating dependencies Resolving dependencies... (1.1s) Writing lock file Now when you use Poetry, a virtual environment with the correct Python versioning will be referenced. The other nuance within our Python code is the inclusion of while..else . The nuance when there is else is if the while loop terminates normally, the else clause will be triggered, but if it is terminated abnormally it will not, for example if break statement is encounted. We can observe this in the following simple example: counter = 0 while counter <= 2 : counter += 1 print ( f \"Counter: { counter } \" ) else : print ( \"Else statement!\" ) # else does not trigger here! counter = 0 while counter < 3 : if counter == 2 : break counter += 1 print ( f \"Counter: { counter } \" ) else : print ( \"Else statement!\" ) Summary We've built the guessing game. Congratulations! We've introduced some Python specific ideas around while..else and the walrus operator := . Next we'll explore common programming concepts within Python.","title":"Guessing Game"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/#setting-up-a-new-project","text":"To setup a new project we'll navigate to the projects directory and make a new project using Poetry like so: $ poetry new guessing_game $ cd guessing_game $ echo 'print(\"Hello, world!\")' > guessing_game/__main__.py Just like in Chapter 1, we'll start by printing \"Hello, world!\" by adding a new file guessing_game/__main__.py . Filename: guessing_game/__main__.py print ( \"Hello, world!\" ) Now we can run this via poetry run as a module: $ poetry run python -m guessing_game Hello, world! We can use this rapidly iterate on a project. Let's modify guessing_game/__main__.py some more.","title":"Setting Up a New Project"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/#processing-a-guess","text":"The first thing we need to achieve in our game is to ask for user input and process that input. To start, we'll allow the player to input a guess. Filename: guessing_game/__main__.py print ( \"Guess the number!\" ) guess = input ( \"Please input your guess: \" ) print ( f \"You guessed: { guess } \" ) We now introduce the input function which enables input. Notice that the resulting variable stored in guess is now a string . When printing out strings in python, you can make use of f-strings, which makes it easier for format strings.","title":"Processing a guess"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/#storing-values-with-variables","text":"Similar to many other dynamic programming languages, python does not distinguish between mutable and immutable types. For example: guess = \"hello\" guess = 10 Is entirely allowable code, even though not only did the variable change, but the type changed as well! We'll go through validation strategies in a later chapter, for now, we can simply try parsing the output. Filename: guessing_game/__main__.py print ( \"Guess the number!\" ) guess = int ( input ( \"Please input your guess: \" )) print ( f \"You guessed: { guess } \" ) This will work as intended for integer inputs $ poetry run python -m guessing_game Guess the number! Please input your guess: 10 You guessed: 10 Now if you input anything that isn't an integer it will raise a ValueError : $ poetry run python -m guessing_game Guess the number! Please input your guess: not a number Please input your guess: not a number Traceback (most recent call last): File \"/bin/python/runpy.py\", line 193, in _run_module_as_main \"__main__\", mod_spec) File \"/bin/python/runpy.py\", line 85, in _run_code exec(code, run_globals) File \"file:///projects/guessing_game/guessing_game/__main__.py\", line 2, in <module> guess = int(input(\"Please input your guess: \")) ValueError: invalid literal for int() with base 10: 'not a number'","title":"Storing Values with Variables"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/#generating-a-secret-number","text":"The next step is to generate a secret number to guess. This number needs to be randomly generated everytime the program is run, so we'll use a random number generator between 1 and 100. As the Python standard libraries include random , we can use this to generate random numbers. Filename: guessing_game/__main__.py import random print ( \"Guess the number!\" ) secret_number = random . randint ( 1 , 100 ) print ( f \"The secret number is: { secret_number } \" ) guess = int ( input ( \"Please input your guess: \" )) print ( f \"You guessed: { guess } \" ) First we add the line: import random . This enables the random module to be used within our project. We then can add the code to generate the number, which is conveniently proivided as random.randint(1, 100) , alternatively we could use random.choice(range(1, 101)) to request a number between 1 and 100. Of course, its not feasible to just try \"guessing\" what methods or functions to use from a python module. Within Python, by convention docstrings are typically used. To view docstrings for rand for example, you can try entering print(rand.__doc__) to read the package level documentation for rand and print(random.randint.__doc__) for the documentation for the randint function. For now we are also printing the secret number for testing purposes - in the final version we would remove it. Otherwise it would not be much of a game! Let's try running the programming a few times. $ poetry run python -m guessing_game Guess the number! The secret number is: 64 Please input your guess: 4 You guessed: 4 $ poetry run python -m guessing_game Guess the number! The secret number is: 49 Please input your guess: 10 You guessed: 10 You should get different random numbers which are between 1 and 100.","title":"Generating a Secret Number"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/#comparing-the-guess-to-the-secret-number","text":"To compare guesses in Python, we will make use of if and else statements. Filename: guessing_game/__main__.py import random print ( \"Guess the number!\" ) secret_number = random . randint ( 1 , 100 ) guess = int ( input ( \"Please input your guess: \" )) if guess < secret_number : print ( \"Too small!\" ) elif guess > secret_number : print ( \"Too big!\" ) else : print ( \"Just right!\" ) Note: at this point in time you would realise whitespace is special in Python! Rather than using curly braces, Python uses whitespace to define the \"scope\" for control flow operations. In Python 3.X, there isn't an inbuilt cmp operator where this can be achieved through pattern matching without additional overhead. Rather than having one guess, we can include a while loop as well Filename: guessing_game/__main__.py import random print ( \"Guess the number!\" ) secret_number = random . randint ( 1 , 100 ) while ( guess := int ( input ( \"Please input your guess: \" ))) != secret_number : if guess < secret_number : print ( \"Too small!\" ) elif guess > secret_number : print ( \"Too big!\" ) else : print ( \"Just right!\" ) This is an example of the walrus operator := , if you are running a version lower than Python 3.8, you may need to split up the code to resemble the below: guess = int ( input ( \"Please input your guess: \" )) while True : # add a way for comparison and guess to be updated. We can also ensure Poetry picks up on these nuances, to explore this further, we should first change the expected Python version to reflect this: Filename: pyproject.toml [tool.poetry.dependencies] python = \"^3.8\" This would indicate at the version of Python is at least Python 3.8, then we should update Poetry so it is aware that our configuration has changed via poetry lock . Then your output should resemble the below: $ poetry lock Updating dependencies Resolving dependencies... (1.1s) Writing lock file Now when you use Poetry, a virtual environment with the correct Python versioning will be referenced. The other nuance within our Python code is the inclusion of while..else . The nuance when there is else is if the while loop terminates normally, the else clause will be triggered, but if it is terminated abnormally it will not, for example if break statement is encounted. We can observe this in the following simple example: counter = 0 while counter <= 2 : counter += 1 print ( f \"Counter: { counter } \" ) else : print ( \"Else statement!\" ) # else does not trigger here! counter = 0 while counter < 3 : if counter == 2 : break counter += 1 print ( f \"Counter: { counter } \" ) else : print ( \"Else statement!\" )","title":"Comparing the Guess to the Secret Number"},{"location":"2.%20Programming%20a%20Guessing%20Game/guessing-game/#summary","text":"We've built the guessing game. Congratulations! We've introduced some Python specific ideas around while..else and the walrus operator := . Next we'll explore common programming concepts within Python.","title":"Summary"},{"location":"3.%20Common%20Programming%20Concepts/01-variables/","text":"As we begin to explore variables in Python, we'll begin by talking about linting and testing. Although almost everything is permissible in Python, this does not mean we shouldn't include type hints to verify that our code works as intended! Typing is optional in Python, but using where we can will ensure our code is more precise, and easier for others to read and reason with. At the end of the day, readable programming is for humans not machines. To get this working, we will introduce mypy as a way to provide typing support to Python. To illustrate this, let\u2019s generate a new project called variables in your projects directory by using poetry new variables . Next we can install mypy using Poetry. $ poetry add mypy Creating virtualenv Using version ^0.910 for mypy Updating dependencies Resolving dependencies... (3.5s) Writing lock file Package operations: 12 installs, 0 updates, 0 removals Now in the new variables folder, we can once again update __main__.py Filename: variables/__main__.py x : int = 5 print ( f \"The value of x is: { x } \" ) x = \"hello\" print ( f \"The value of x is: { x } \" ) What happens if we run this? It will work as expected - which seems a bit underwhelming! $ poetry run python -m variables The value of x is: 5 The value of x is: hello Now if we run mypy over this, we should get an error instead! $ poetry run mypy variables variables/__main__.py:3: error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\") Found 1 error in 1 file (checked 2 source files) This example shows how we can provide static type checking for Python. In Python, there isn't a concept of constants, or separation between immutable or mutable types, instead Python depends on conventions. For example, under PEP8 guidelines constants are written in capital letters with underscores separating words.","title":"Variables and Assignment"},{"location":"3.%20Common%20Programming%20Concepts/02-datatypes/","text":"Python is a dynamically typed language, though we can still apply type hints to our variables as shown in the previous section. Simple Types Here are examples of some common built-in types: Type Description int integer float floating point number bool boolean value (subclass of int) str string (unicode in Python 3) bytes 8-bit string object an arbitrary object (object is the common base class) Within the standard library there is not the concept of precision within Python, though this is typeically included and extended within the numpy libraries and other scientific computing frameworks. Similar to Rust, mypy can infer what type we wanted to provide and provide checks to ensure it adheres to our expectation. For example the code below would fail, even without type hints when running mypy . Filename: variables/__main__.py s = 1 s = \"hello\" $ poetry run mypy variables variables/__main__.py:2: error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\") Found 1 error in 1 file (checked 2 source files) Though we can modify this to take Any hint which will allow this! Filename: variables/__main__.py from typing import Any s : Any = 1 s = \"hello\" $ poetry run mypy variables Success: no issues found in 2 source files However as it is a static checker, it does not necessarily assert whether the actual outcome is what we expect. For example, just because we provide a type hint as int , it offers no guarentees that the variable in the Python program reflects that type! Filename: variables/__main__.py s : float = 1 print ( f \"Variable is of type: { type ( s ) } \" ) $ poetry run mypy variables Success: no issues found in 2 source files $ poetry run python -m variables Variable is of type: <class 'int'> Compound Types Compound types can group multiple values into one type. Python has a few key ones, around Dict , List , Set , Tuple types, which also have generic variation in the form Iterable , Sequence , Mapping . These generally operate in the way you might expect. The Tuple Type A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size. We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don\u2019t have to be the same. We\u2019ve added optional type annotations in this example: Filename: variables/__main__.py from typing import Tuple tup : Tuple [ int , float , str ] = ( 1 , 2.5 , \"Hello, world!\" ) # we can use pattern matching to deconstruct the tuple x , y , z = tup print ( f \"The value of y is: { y } \" ) The List Type Another way in Python to have a collection of multiple values is to use a list , which is known in other programming languages as an array . In Python, a list can also be appropriately typed, we can mix types together using Union Filename: variables/__main__.py from typing import List , Union a : List [ Union [ float , str ]] = [ 1.0 , 2.5 , \"Hello, world!\" ] In Python, lists are 0-indexed and can be accessed as so: from typing import List a : List [ int ] = [ 1 , 2 , 3 , 4 , 5 ] print ( f \"The first element is { a [ 0 ] } \" ) print ( f \"The second last element is { a [ - 2 ] } \" ) The Dict Type In Python, a built-in type is dict or dictionary, which is known in other programming languages as a hash table . In Python, dictionaries can be typed as well, so that all keys and their corresponding values hold the same type. Dictionary values can be accessed by their keys Filename: variables/__main__.py from typing import Dict a : Dict [ str , int ] = { \"hello\" : 0 , \"world\" : 25 } my_key : str = \"hello\" print ( f \"The value for key: { my_key } is: { a [ my_key ] } \" ) What happens when you try accessing a key which does not exist? Filename: variables/__main__.py from typing import Dict a : Dict [ str , int ] = { \"hello\" : 0 , \"world\" : 25 } my_key : str = \"invalid\" print ( f \"The value for key: { my_key } is: { a [ my_key ] } \" ) # KeyError: 'invalid' Python also provides a convenient get method to access values in a dictionary with the optional value when the key is not present. Filename: variables/__main__.py from typing import Dict a : Dict [ str , int ] = { \"hello\" : 0 , \"world\" : 25 } my_key : str = \"invalid\" print ( f \"The value for key: { my_key } is: { a . get ( my_key , - 1 ) } \" ) This demonstrates very broadly basic data types in Python, and how we can use mypy for static type checking.","title":"Data Types"},{"location":"3.%20Common%20Programming%20Concepts/02-datatypes/#simple-types","text":"Here are examples of some common built-in types: Type Description int integer float floating point number bool boolean value (subclass of int) str string (unicode in Python 3) bytes 8-bit string object an arbitrary object (object is the common base class) Within the standard library there is not the concept of precision within Python, though this is typeically included and extended within the numpy libraries and other scientific computing frameworks. Similar to Rust, mypy can infer what type we wanted to provide and provide checks to ensure it adheres to our expectation. For example the code below would fail, even without type hints when running mypy . Filename: variables/__main__.py s = 1 s = \"hello\" $ poetry run mypy variables variables/__main__.py:2: error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\") Found 1 error in 1 file (checked 2 source files) Though we can modify this to take Any hint which will allow this! Filename: variables/__main__.py from typing import Any s : Any = 1 s = \"hello\" $ poetry run mypy variables Success: no issues found in 2 source files However as it is a static checker, it does not necessarily assert whether the actual outcome is what we expect. For example, just because we provide a type hint as int , it offers no guarentees that the variable in the Python program reflects that type! Filename: variables/__main__.py s : float = 1 print ( f \"Variable is of type: { type ( s ) } \" ) $ poetry run mypy variables Success: no issues found in 2 source files $ poetry run python -m variables Variable is of type: <class 'int'>","title":"Simple Types"},{"location":"3.%20Common%20Programming%20Concepts/02-datatypes/#compound-types","text":"Compound types can group multiple values into one type. Python has a few key ones, around Dict , List , Set , Tuple types, which also have generic variation in the form Iterable , Sequence , Mapping . These generally operate in the way you might expect.","title":"Compound Types"},{"location":"3.%20Common%20Programming%20Concepts/02-datatypes/#the-tuple-type","text":"A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size. We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don\u2019t have to be the same. We\u2019ve added optional type annotations in this example: Filename: variables/__main__.py from typing import Tuple tup : Tuple [ int , float , str ] = ( 1 , 2.5 , \"Hello, world!\" ) # we can use pattern matching to deconstruct the tuple x , y , z = tup print ( f \"The value of y is: { y } \" )","title":"The Tuple Type"},{"location":"3.%20Common%20Programming%20Concepts/02-datatypes/#the-list-type","text":"Another way in Python to have a collection of multiple values is to use a list , which is known in other programming languages as an array . In Python, a list can also be appropriately typed, we can mix types together using Union Filename: variables/__main__.py from typing import List , Union a : List [ Union [ float , str ]] = [ 1.0 , 2.5 , \"Hello, world!\" ] In Python, lists are 0-indexed and can be accessed as so: from typing import List a : List [ int ] = [ 1 , 2 , 3 , 4 , 5 ] print ( f \"The first element is { a [ 0 ] } \" ) print ( f \"The second last element is { a [ - 2 ] } \" )","title":"The List Type"},{"location":"3.%20Common%20Programming%20Concepts/02-datatypes/#the-dict-type","text":"In Python, a built-in type is dict or dictionary, which is known in other programming languages as a hash table . In Python, dictionaries can be typed as well, so that all keys and their corresponding values hold the same type. Dictionary values can be accessed by their keys Filename: variables/__main__.py from typing import Dict a : Dict [ str , int ] = { \"hello\" : 0 , \"world\" : 25 } my_key : str = \"hello\" print ( f \"The value for key: { my_key } is: { a [ my_key ] } \" ) What happens when you try accessing a key which does not exist? Filename: variables/__main__.py from typing import Dict a : Dict [ str , int ] = { \"hello\" : 0 , \"world\" : 25 } my_key : str = \"invalid\" print ( f \"The value for key: { my_key } is: { a [ my_key ] } \" ) # KeyError: 'invalid' Python also provides a convenient get method to access values in a dictionary with the optional value when the key is not present. Filename: variables/__main__.py from typing import Dict a : Dict [ str , int ] = { \"hello\" : 0 , \"world\" : 25 } my_key : str = \"invalid\" print ( f \"The value for key: { my_key } is: { a . get ( my_key , - 1 ) } \" ) This demonstrates very broadly basic data types in Python, and how we can use mypy for static type checking.","title":"The Dict Type"},{"location":"3.%20Common%20Programming%20Concepts/03-functions/","text":"Functions Liek many other programming languages, functions are an integral part of Python programming. In Python, functions start with the def keyword which allows you to declare new functions. Python code uses snake case as the convention for function and variable names. In snake case, all letters are lowercase and underscores separate words. Here\u2019s a program that contains an example function definition: Filename: variables/__main__.py def say_hello (): print ( \"Hello!\" ) say_hello () Function Parameters Functions can also be defined to have parameters , which are special variables that are part of a function's signature. When a function has parameters, you can provide it with concrete values for those parameters. We can add a parameter to our function say_hello to let it say hello to someone. Filename: variables/__main__.py def say_hello ( x : str ): print ( f \"Hello { x } !\" ) say_hello ( \"world\" ) # Hello world! As with type hints, in Python these are optional, we can also use mypy in the way you would expect Filename: variables/__main__.py def say_hello ( x : str ): print ( f \"Hello { x } !\" ) say_hello ( 123 ) poetry run mypy variables variables/__main__.py:4: error: Argument 1 to \"say_hello\" has incompatible type \"int\"; expected \"str\" Found 1 error in 1 file (checked 2 source files) Functions can also take multiple parameters which are separated by a comma, and we can provide type hints for the output of a function using -> . To output the return of a function you would need to use the return keyword Filename: variables/__main__.py def five () -> int : return 5 print ( five ()) $ poetry run python -m variables 5 We can combine the two ideas to have a function with a function signature and also a return type Filename: variables/__main__.py def add_one ( x : int ) -> int : return x + 1 print ( add_one ( 5 )) $ poetry run python -m variables 6","title":"Functions"},{"location":"3.%20Common%20Programming%20Concepts/03-functions/#functions","text":"Liek many other programming languages, functions are an integral part of Python programming. In Python, functions start with the def keyword which allows you to declare new functions. Python code uses snake case as the convention for function and variable names. In snake case, all letters are lowercase and underscores separate words. Here\u2019s a program that contains an example function definition: Filename: variables/__main__.py def say_hello (): print ( \"Hello!\" ) say_hello ()","title":"Functions"},{"location":"3.%20Common%20Programming%20Concepts/03-functions/#function-parameters","text":"Functions can also be defined to have parameters , which are special variables that are part of a function's signature. When a function has parameters, you can provide it with concrete values for those parameters. We can add a parameter to our function say_hello to let it say hello to someone. Filename: variables/__main__.py def say_hello ( x : str ): print ( f \"Hello { x } !\" ) say_hello ( \"world\" ) # Hello world! As with type hints, in Python these are optional, we can also use mypy in the way you would expect Filename: variables/__main__.py def say_hello ( x : str ): print ( f \"Hello { x } !\" ) say_hello ( 123 ) poetry run mypy variables variables/__main__.py:4: error: Argument 1 to \"say_hello\" has incompatible type \"int\"; expected \"str\" Found 1 error in 1 file (checked 2 source files) Functions can also take multiple parameters which are separated by a comma, and we can provide type hints for the output of a function using -> . To output the return of a function you would need to use the return keyword Filename: variables/__main__.py def five () -> int : return 5 print ( five ()) $ poetry run python -m variables 5 We can combine the two ideas to have a function with a function signature and also a return type Filename: variables/__main__.py def add_one ( x : int ) -> int : return x + 1 print ( add_one ( 5 )) $ poetry run python -m variables 6","title":"Function Parameters"},{"location":"3.%20Common%20Programming%20Concepts/04-comments-and-docstrings/","text":"Comments All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or comments, in their source code that the compiler will ignore but people reading the source code may find useful. Here\u2019s a simple comment: # hello, world In Python, the idiomatic comment style starts a comment with a single hash character # , and the comment continues until the end of the line. Comments can be placed at the end of lines containing code: Filename: variables/__main__.py lucky_number = 7 # I'm feeling lucky today Comments can be used for much more, including type checking in mypy , as shown below Filename: variables/__main__.py lucky_number = 7 # type: int Multi-line comments can be represented by triple quotations, though by convention these are typically used as docstrings and documentation within a Python file. Filename: variables/__main__.py def say_hello ( x : str ): \"\"\" Says hello Parameters ---------- x : str Says hello to {x} \"\"\" print ( f \"Hello { x } \" ) print ( say_hello . __doc__ ) $ poetry run python -m variables Says hello Parameters ---------- x : str Says hello to {x} These can also appear at the module level at the top of a file! To demonstrate this we will alter __init__.py file instead Filename: variables/__init__.py \"\"\" This is a docstring! \"\"\" __version__ = '0.1.0' Filename: variables/__main__.py import variables ; print ( variables . __doc__ ) $ poetry run python -m variables This is a docstring! Docstrings actually have a very lengthy PEP guideline which is worth considering as part of Python development.","title":"Comments and Docstrings"},{"location":"3.%20Common%20Programming%20Concepts/04-comments-and-docstrings/#comments","text":"All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or comments, in their source code that the compiler will ignore but people reading the source code may find useful. Here\u2019s a simple comment: # hello, world In Python, the idiomatic comment style starts a comment with a single hash character # , and the comment continues until the end of the line. Comments can be placed at the end of lines containing code: Filename: variables/__main__.py lucky_number = 7 # I'm feeling lucky today Comments can be used for much more, including type checking in mypy , as shown below Filename: variables/__main__.py lucky_number = 7 # type: int Multi-line comments can be represented by triple quotations, though by convention these are typically used as docstrings and documentation within a Python file. Filename: variables/__main__.py def say_hello ( x : str ): \"\"\" Says hello Parameters ---------- x : str Says hello to {x} \"\"\" print ( f \"Hello { x } \" ) print ( say_hello . __doc__ ) $ poetry run python -m variables Says hello Parameters ---------- x : str Says hello to {x} These can also appear at the module level at the top of a file! To demonstrate this we will alter __init__.py file instead Filename: variables/__init__.py \"\"\" This is a docstring! \"\"\" __version__ = '0.1.0' Filename: variables/__main__.py import variables ; print ( variables . __doc__ ) $ poetry run python -m variables This is a docstring! Docstrings actually have a very lengthy PEP guideline which is worth considering as part of Python development.","title":"Comments"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/","text":"Control Flow Deciding whether or not to run some code depending on if a condition is true and deciding to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Python code are if expressions and loops. if Expressions An if expression allows you to branch your code depending on conditions. You provide a condition and then state, \u201cIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.\u201d Create a new project called branches in your projects directory to explore the if expression. In the branches/__main.py__ file, input the following: Filename: branches/__main__.py number = 3 if number < 5 : print ( \"condition was true\" ) else : print ( \"condition was false\" ) All if expressions start with the keyword if , which is followed by a condition. In this case, the condition checks whether or not the variable number has a value less than 5. The block of code we want to execute if the condition is true is placed within the same indented code block. Optionally, we can also include an else expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to false. If you don\u2019t provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code. Let's see this in action $ poetry run python -m branches condition was true If we change the value of number to a value that makes a condition false, let's see what happens number = 7 Run the program again and look at the output $ poetry run python -m branches condition was false In Python, the conditions need not be boolean! Python only requires \"truthy\" or \"falsy\" values, this is performed by Python casting things via bool automatically. Type Truthy Falsy int Any non-zero 0 float Any non-zero 0.0 bool true false str Any non-empty string \"\" list Any non-empty list [] tuple Any non-empty tuple () set Any non-empty set set() dict Any non-empty dictionary {} We can observe this in the following simple example number = 3 if number : print ( f \"The number: { number } , is non-zero\" ) Handling Multiple Conditions with elif You can have multiple conditions by combining if and else in an elif expression. For example: Filename: branches/__main__.py number = 6 if number % 4 == 0 : print ( \"number is divisible by 4\" ) elif number % 3 == 0 : print ( \"number is divisible by 3\" ) elif number % 2 == 0 : print ( \"number is divisible by 2\" ) else : print ( \"number is not divisible by 4, 3, or 2\" ) This program has four possible paths it can take. After running it, you should see the following output: $ poetry run python -m branches number is divisible by 3 When this program executes, it checks each if expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don\u2019t see the output number is divisible by 2 , nor do we see the number is not divisible by 4, 3, or 2 text from the else block. That\u2019s because Python only executes the block for the first true condition, and once it finds one, it doesn\u2019t even check the rest. Python also provides support for a ternary operator, which is shown below Filename: branches/__main__.py condition = True number = 5 if condition else 6 print ( f \"The value of number is: { number } \" ) Notice that mypy can still be applied in this setting as we might expect. Filename: branches/__main__.py condition : bool = True number : int = 5 if condition else 6 print ( f \"The value of number is: { number } \" ) $ poetry run mypy branches Success: no issues found in 2 source files Repetition with Loops It\u2019s often useful to execute a block of code more than once. For this task, Rust provides several loops. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning. To experiment with loops, let\u2019s make a new project called loops. Python has two kinds of loops: for , while . Let's have a look at each one. Repeating Code with while True: If we use the statement while True: , it tells Python to execute the code block over and over again forever or until you tell it to stop. Loops can also use two special keywords, being continue which tells the program to skip over reamining code and proceed to the next iteration, and break which is to cease execution of the loop code block and continue. Having loops within loops would only affect the innermost loop. In Python, there does not exist a mechanism to break out of multiple loops at once, instead various design patterns can be used to accomplish this instead. Filename: loops/__main__.py count : int = 0 while True : if count == 5 : break count += 1 print ( f \"count = { count } \" ) $ poetry run python -m loops count = 1 count = 2 count = 3 count = 4 count = 5 Conditional Loops with while A better pattern for managing loops is to enable conditional loops, we saw a variation of this in the guessing game, which was used in conjunction with the walrus operator. We can use a program which loops three times, counting down each time and printing a message before exiting. Filename: loops/__main__.py number = 3 while number != 0 : print ( f \" { number } !\" ) number -= 1 print ( \"LIFTOFF!!!\" ) $ poetry run python -m loops 3! 2! 1! LIFTOFF!!! Notice that logically this is equivalent to the while...else pattern which was introduced in the guessing game shown below Filename: loops/__main__.py number = 3 while number != 0 : print ( f \" { number } !\" ) number -= 1 else : print ( \"LIFTOFF!!!\" ) Looping Through a Collection with for Another way is to use the for loop which can be used over a collection. Filename: loops/__main__.py from typing import List a : List [ int ] = [ 10 , 20 , 30 , 40 , 50 ] index : int = 0 while index < 5 : print ( f \"The value at index: { index } is: { a [ index ] } \" ) index += 1 Here the code counts up through the elements in the array starting from index 0 until it reaches the final index in the array. $ poetry run python -m loops The value at index: 0 is: 10 The value at index: 1 is: 20 The value at index: 2 is: 30 The value at index: 3 is: 40 The value at index: 4 is: 50 This approach is problematic, as we have to know the test condition or the index value. A more concise alternative is to use a for loop Filename: loops/__main__.py from typing import List a : List [ int ] = [ 10 , 20 , 30 , 40 , 50 ] for element in a : print ( f \"The value is { element } \" ) If we need to keep the index, we use enumerate with the for loop Filename: loops/__main__.py from typing import List a : List [ int ] = [ 10 , 20 , 30 , 40 , 50 ] for index , element in enumerate ( a ): print ( f \"The value at index: { index } is: { element } \" ) Not only is this code more concise and produces the same output as the example using while loop, it is safer, as we have eliminated the chance of bugs that result of going beyond the end of the list. We can use for loops on collections which are not lists as well. For example over dictionaries. Filename: loops/__main__.py from typing import Dict a : Dict [ str , int ] = { \"a\" : 10 , \"b\" : 20 } for key in a : print ( f \"At key { key } , we have value { a [ key ] } \" ) Or a more readable version Filename: loops/__main__.py from typing import Dict a : Dict [ str , int ] = { \"a\" : 10 , \"b\" : 20 } for key , value in a . items (): print ( f \"At key { key } , we have value { a [ key ] } \" ) We can also refactor our countdown example to leverage Python's built-in range function Filename: loops/__main__.py for count in range ( 3 , 0 , - 1 ): print ( f \" { count } !\" ) print ( \"LIFTOFF!!!\" ) We can also use else in the for..else pattern Filename: loops/__main__.py for count in range ( 3 , 0 , - 1 ): print ( f \" { count } !\" ) else : print ( \"LIFTOFF!!!\" ) Or even the reverse list slice operation Filename: loops/__main__.py for count in range ( 1 , 4 )[:: - 1 ]: print ( f \" { count } !\" ) print ( \"LIFTOFF!!!\" ) Depending on context, each one of these variations have their place. In general use the option which makes the code the most readable! Summary Here ends a chapter on Python and how it handles variables, functions, comments, and control flow! Next we'll examine ways for building data structured in a way which provides validation and typing on runtime.","title":"Control Flow"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#control-flow","text":"Deciding whether or not to run some code depending on if a condition is true and deciding to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Python code are if expressions and loops.","title":"Control Flow"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#if-expressions","text":"An if expression allows you to branch your code depending on conditions. You provide a condition and then state, \u201cIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.\u201d Create a new project called branches in your projects directory to explore the if expression. In the branches/__main.py__ file, input the following: Filename: branches/__main__.py number = 3 if number < 5 : print ( \"condition was true\" ) else : print ( \"condition was false\" ) All if expressions start with the keyword if , which is followed by a condition. In this case, the condition checks whether or not the variable number has a value less than 5. The block of code we want to execute if the condition is true is placed within the same indented code block. Optionally, we can also include an else expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to false. If you don\u2019t provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code. Let's see this in action $ poetry run python -m branches condition was true If we change the value of number to a value that makes a condition false, let's see what happens number = 7 Run the program again and look at the output $ poetry run python -m branches condition was false In Python, the conditions need not be boolean! Python only requires \"truthy\" or \"falsy\" values, this is performed by Python casting things via bool automatically. Type Truthy Falsy int Any non-zero 0 float Any non-zero 0.0 bool true false str Any non-empty string \"\" list Any non-empty list [] tuple Any non-empty tuple () set Any non-empty set set() dict Any non-empty dictionary {} We can observe this in the following simple example number = 3 if number : print ( f \"The number: { number } , is non-zero\" )","title":"if Expressions"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#handling-multiple-conditions-with-elif","text":"You can have multiple conditions by combining if and else in an elif expression. For example: Filename: branches/__main__.py number = 6 if number % 4 == 0 : print ( \"number is divisible by 4\" ) elif number % 3 == 0 : print ( \"number is divisible by 3\" ) elif number % 2 == 0 : print ( \"number is divisible by 2\" ) else : print ( \"number is not divisible by 4, 3, or 2\" ) This program has four possible paths it can take. After running it, you should see the following output: $ poetry run python -m branches number is divisible by 3 When this program executes, it checks each if expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don\u2019t see the output number is divisible by 2 , nor do we see the number is not divisible by 4, 3, or 2 text from the else block. That\u2019s because Python only executes the block for the first true condition, and once it finds one, it doesn\u2019t even check the rest. Python also provides support for a ternary operator, which is shown below Filename: branches/__main__.py condition = True number = 5 if condition else 6 print ( f \"The value of number is: { number } \" ) Notice that mypy can still be applied in this setting as we might expect. Filename: branches/__main__.py condition : bool = True number : int = 5 if condition else 6 print ( f \"The value of number is: { number } \" ) $ poetry run mypy branches Success: no issues found in 2 source files","title":"Handling Multiple Conditions with elif"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#repetition-with-loops","text":"It\u2019s often useful to execute a block of code more than once. For this task, Rust provides several loops. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning. To experiment with loops, let\u2019s make a new project called loops. Python has two kinds of loops: for , while . Let's have a look at each one.","title":"Repetition with Loops"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#repeating-code-with-while-true","text":"If we use the statement while True: , it tells Python to execute the code block over and over again forever or until you tell it to stop. Loops can also use two special keywords, being continue which tells the program to skip over reamining code and proceed to the next iteration, and break which is to cease execution of the loop code block and continue. Having loops within loops would only affect the innermost loop. In Python, there does not exist a mechanism to break out of multiple loops at once, instead various design patterns can be used to accomplish this instead. Filename: loops/__main__.py count : int = 0 while True : if count == 5 : break count += 1 print ( f \"count = { count } \" ) $ poetry run python -m loops count = 1 count = 2 count = 3 count = 4 count = 5","title":"Repeating Code with while True:"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#conditional-loops-with-while","text":"A better pattern for managing loops is to enable conditional loops, we saw a variation of this in the guessing game, which was used in conjunction with the walrus operator. We can use a program which loops three times, counting down each time and printing a message before exiting. Filename: loops/__main__.py number = 3 while number != 0 : print ( f \" { number } !\" ) number -= 1 print ( \"LIFTOFF!!!\" ) $ poetry run python -m loops 3! 2! 1! LIFTOFF!!! Notice that logically this is equivalent to the while...else pattern which was introduced in the guessing game shown below Filename: loops/__main__.py number = 3 while number != 0 : print ( f \" { number } !\" ) number -= 1 else : print ( \"LIFTOFF!!!\" )","title":"Conditional Loops with while"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#looping-through-a-collection-with-for","text":"Another way is to use the for loop which can be used over a collection. Filename: loops/__main__.py from typing import List a : List [ int ] = [ 10 , 20 , 30 , 40 , 50 ] index : int = 0 while index < 5 : print ( f \"The value at index: { index } is: { a [ index ] } \" ) index += 1 Here the code counts up through the elements in the array starting from index 0 until it reaches the final index in the array. $ poetry run python -m loops The value at index: 0 is: 10 The value at index: 1 is: 20 The value at index: 2 is: 30 The value at index: 3 is: 40 The value at index: 4 is: 50 This approach is problematic, as we have to know the test condition or the index value. A more concise alternative is to use a for loop Filename: loops/__main__.py from typing import List a : List [ int ] = [ 10 , 20 , 30 , 40 , 50 ] for element in a : print ( f \"The value is { element } \" ) If we need to keep the index, we use enumerate with the for loop Filename: loops/__main__.py from typing import List a : List [ int ] = [ 10 , 20 , 30 , 40 , 50 ] for index , element in enumerate ( a ): print ( f \"The value at index: { index } is: { element } \" ) Not only is this code more concise and produces the same output as the example using while loop, it is safer, as we have eliminated the chance of bugs that result of going beyond the end of the list. We can use for loops on collections which are not lists as well. For example over dictionaries. Filename: loops/__main__.py from typing import Dict a : Dict [ str , int ] = { \"a\" : 10 , \"b\" : 20 } for key in a : print ( f \"At key { key } , we have value { a [ key ] } \" ) Or a more readable version Filename: loops/__main__.py from typing import Dict a : Dict [ str , int ] = { \"a\" : 10 , \"b\" : 20 } for key , value in a . items (): print ( f \"At key { key } , we have value { a [ key ] } \" ) We can also refactor our countdown example to leverage Python's built-in range function Filename: loops/__main__.py for count in range ( 3 , 0 , - 1 ): print ( f \" { count } !\" ) print ( \"LIFTOFF!!!\" ) We can also use else in the for..else pattern Filename: loops/__main__.py for count in range ( 3 , 0 , - 1 ): print ( f \" { count } !\" ) else : print ( \"LIFTOFF!!!\" ) Or even the reverse list slice operation Filename: loops/__main__.py for count in range ( 1 , 4 )[:: - 1 ]: print ( f \" { count } !\" ) print ( \"LIFTOFF!!!\" ) Depending on context, each one of these variations have their place. In general use the option which makes the code the most readable!","title":"Looping Through a Collection with for"},{"location":"3.%20Common%20Programming%20Concepts/05-control-flow/#summary","text":"Here ends a chapter on Python and how it handles variables, functions, comments, and control flow! Next we'll examine ways for building data structured in a way which provides validation and typing on runtime.","title":"Summary"},{"location":"4.%20Data%20Structures%20in%20Python/01-data-structures/","text":"In many programming languages, we would use a struct or structure as a custom data type that enables you to name and package together multiple related values that make up a meaningful group. There are many patterns within Python that can be used, in this book we'll describe an opinionated way which uses data classes and extensions in pydantic to enforce run-time data validation in Python.","title":"Data Classes in Python"},{"location":"4.%20Data%20Structures%20in%20Python/02-basemodel/","text":"To get started let's create a new project called structures poetry new structures , and introduce pydantic as a way to provide run-time type validation. We can then install pydantic using Poetry. $ poetry add mypy pydantic Creating virtualenv Using version ^0.910 for mypy Using version ^1.8.2 for pydantic Updating dependencies Resolving dependencies... (3.6s) Writing lock file Package operations: 13 installs, 0 updates, 0 removals \u2022 Installing pyparsing (3.0.6) \u2022 Installing attrs (21.2.0) \u2022 Installing more-itertools (8.12.0) \u2022 Installing mypy-extensions (0.4.3) \u2022 Installing packaging (21.3) \u2022 Installing pluggy (0.13.1) \u2022 Installing py (1.11.0) \u2022 Installing toml (0.10.2) \u2022 Installing typing-extensions (4.0.0) \u2022 Installing wcwidth (0.2.5) \u2022 Installing mypy (0.910) \u2022 Installing pydantic (1.8.2) \u2022 Installing pytest (5.4.3) We can also include the pydantic mypy plugin . We can do this by adding the following to pyproject.toml Filename: pyproject.toml (.. snip ..) [mypy] plugins = pydantic . mypy Defining and Instantiating Data Objects There are many patterns for packaging related variables in Python, including the used of dictionaries or named tuples. If the input data is can be well-structured, Pydantic offers BaseModel , as a way to define these structures and enable the pieces of data to be grouped together. More specifically Pydantic offers additional support to provide run-time type validation to Python. from pydantic import BaseModel class User ( BaseModel ): active : bool username : str email : str sign_in_count : int We can create an instance of this data model by specifying concrete values for each of the fields. An instance is created by provided the name of the data model, and providing the key, value pairs as parameters and their corresponding values. For example, we can declare a particular user based on above as follows: user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 ) As this is just a Python object, we can change the value of an attribute and they are mutable as we expect: user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 ) user1 . email = \"anotheremail@example.com\" When using BaseModel data model objects can be compared, and sorted, whereas using Python objects, this is not possible with writing additional code. Filename: structures/__main__.py from pydantic import BaseModel class User ( BaseModel ): active : bool username : str email : str sign_in_count : int class UserModel ( object ): def __init__ ( self , active : bool , username : str , email : str , sign_in_count : int ): self . active = active self . username = username self . email = email self . sign_in_count = sign_in_count user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) user2 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) print ( f \"user1 and user2 - are they equal? { user1 == user2 } \" ) user1 = UserModel ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) user2 = UserModel ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) print ( f \"user1 and user2 - are they equal? { user1 == user2 } \" ) If we run the above code, we can see when using the appropriate dataclass, the objects can be compared, whereas when using vanilla Python objects $ poetry run python -m structures user1 and user2 - are they equal? True user1 and user2 - are they equal? False Another big difference in using Pydantic is runtime validation. If as a user the incorrect data type is provided, the code will error out at runtime. Filename: structures/__main__.py from pydantic import BaseModel class User ( BaseModel ): active : bool username : str email : str sign_in_count : int user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = \"one\" , ) print ( user1 ) Then when you run the resulting code will raise an error: $ poetry run python -m structures Traceback (most recent call last): (..snip..) File \"~/projects/structures/structures/__main__.py\", line 10, in <module> user1 = User( File \"pydantic/main.py\", line 406, in pydantic.main.BaseModel.__init__ pydantic.error_wrappers.ValidationError: 1 validation error for User sign_in_count value is not a valid integer (type=type_error.integer) With minimal effect we can provide pythonic code that provides runtime validation!","title":"Getting Started with Pydantic"},{"location":"4.%20Data%20Structures%20in%20Python/02-basemodel/#defining-and-instantiating-data-objects","text":"There are many patterns for packaging related variables in Python, including the used of dictionaries or named tuples. If the input data is can be well-structured, Pydantic offers BaseModel , as a way to define these structures and enable the pieces of data to be grouped together. More specifically Pydantic offers additional support to provide run-time type validation to Python. from pydantic import BaseModel class User ( BaseModel ): active : bool username : str email : str sign_in_count : int We can create an instance of this data model by specifying concrete values for each of the fields. An instance is created by provided the name of the data model, and providing the key, value pairs as parameters and their corresponding values. For example, we can declare a particular user based on above as follows: user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 ) As this is just a Python object, we can change the value of an attribute and they are mutable as we expect: user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 ) user1 . email = \"anotheremail@example.com\" When using BaseModel data model objects can be compared, and sorted, whereas using Python objects, this is not possible with writing additional code. Filename: structures/__main__.py from pydantic import BaseModel class User ( BaseModel ): active : bool username : str email : str sign_in_count : int class UserModel ( object ): def __init__ ( self , active : bool , username : str , email : str , sign_in_count : int ): self . active = active self . username = username self . email = email self . sign_in_count = sign_in_count user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) user2 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) print ( f \"user1 and user2 - are they equal? { user1 == user2 } \" ) user1 = UserModel ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) user2 = UserModel ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = 1 , ) print ( f \"user1 and user2 - are they equal? { user1 == user2 } \" ) If we run the above code, we can see when using the appropriate dataclass, the objects can be compared, whereas when using vanilla Python objects $ poetry run python -m structures user1 and user2 - are they equal? True user1 and user2 - are they equal? False Another big difference in using Pydantic is runtime validation. If as a user the incorrect data type is provided, the code will error out at runtime. Filename: structures/__main__.py from pydantic import BaseModel class User ( BaseModel ): active : bool username : str email : str sign_in_count : int user1 = User ( email = \"someone@example.com\" , username = \"somerusername123\" , active = True , sign_in_count = \"one\" , ) print ( user1 ) Then when you run the resulting code will raise an error: $ poetry run python -m structures Traceback (most recent call last): (..snip..) File \"~/projects/structures/structures/__main__.py\", line 10, in <module> user1 = User( File \"pydantic/main.py\", line 406, in pydantic.main.BaseModel.__init__ pydantic.error_wrappers.ValidationError: 1 validation error for User sign_in_count value is not a valid integer (type=type_error.integer) With minimal effect we can provide pythonic code that provides runtime validation!","title":"Defining and Instantiating Data Objects"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/","text":"An Example Program using Pydantic To understand how we can leverage these data models, let's write a program that calculates the area of a rectangle. We'll start with variables and gradually refactor the program. We'll begin by creating a new project with Poetry called rectangles that will take the width and height of a rectangle specified in pixels and calculate the area. Filename: rectangles/__main__.py def area ( width : float , height : float ) -> float : return width * height width : float = 30 height : float = 50 print ( f \"The area of the rectange is { area ( width , height ) } square pixels.\" ) The area function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that\u2019s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. Refactoring with Pydantic: Adding more Meaning Filename: rectangles/__main__.py from pydantic import BaseModel class Rectangle ( BaseModel ): width : float height : float def area ( rect : Rectangle ) -> float : return rect . width * rect . height rect = Rectangle ( width = 30 , height = 50 ) print ( f \"The area of the rectangle is { area ( rect ) } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) Here we have defined a data class object named Rectangle , which has the width and height defined. We can further extend this example by changing area to be a method Defining methods in Python Let's change the area function which has Rectangle instance as a parameter to be the area method as part of the Rectangle object itself. Filename: rectangles/__main__.py from pydantic import BaseModel class Rectangle ( BaseModel ): width : float height : float def area ( self ) -> float : return self . width * self . height rect = Rectangle ( width = 30 , height = 50 ) print ( f \"The area of the rectangle is { rect . area () } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) To define a method, we use whitespace indent a method which allows it to be associated to the Rectangle object. We accomplish this by moving the area function and change the signature to be self in the signature and everywhere else within the the area method. Then we can use the method syntax to call the area method on our Rectangle instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments. The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of self in every method\u2019s signature, is for organization. Next we can add further validation to the Rectangle object, which ensures width and height upon instantiation is always non-zero. Filename: rectangles/__main__.py from pydantic import BaseModel , validator class Rectangle ( BaseModel ): width : float height : float @validator ( 'width' , 'height' ) def check_positive_size ( cls , v ): if v <= 0 : raise ValueError ( \"Width and height of a rectange needs to be a positive number\" ) return v def area ( self ) -> float : return self . width * self . height rect = Rectangle ( width = 30 , height = 50 ) print ( f \"The area of the rectangle is { rect . area () } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) You can try changing width or height to be zero or less, which should then raise a ValueError , which demonstrates the runtime validation which is enabled as part of Pydantic. Methods with Parameters Let's implement an additional method to the Rectangle object, which takes another instance of Rectangle and returns True if the second Rectangle can fit completely within self ; otherwise it should return false . Filename: rectangles/__main__.py from pydantic import BaseModel , validator from typing import Any class Rectangle ( BaseModel ): width : float height : float @validator ( 'width' , 'height' ) def check_positive_size ( cls , v ): if v <= 0 : raise ValueError ( \"Width and height of a rectange needs to be a positive number\" ) return v def area ( self ) -> float : return self . width * self . height def can_hold ( self , rect : Any ) -> bool : return self . width > rect . width and self . height > rect . height rect = Rectangle ( width = 30 , height = 50 ) rect2 = Rectangle ( width = 20 , height = 40 ) print ( f \"Can rect hold rect2? { rect . can_hold ( rect2 ) } \" ) Unfortunately in the current versions of Python, type annotations won't work in the way we might expect. That is if the method signature resembles def can_hold ( self , rect : Rectangle ) -> bool : return self . width > rect . width and self . height > rect . height Python would complain, to somewhat resolve this I've replaced it with Any . It is possible with some refactoring to get around this issue, but it may sacrifice readability. Using classmethod Class method can be used if we wish to construct or use methods associated with the object itself. They can be used as a constructor. An example is if we wish to make it easier to create a square from Rectangle rather than specifying the same value twice Filename: rectanges/__main__.py from pydantic import BaseModel , validator class Rectangle ( BaseModel ): width : float height : float @validator ( 'width' , 'height' ) def check_positive_size ( cls , v ): if v <= 0 : raise ValueError ( \"Width and height of a rectange needs to be a positive number\" ) return v @classmethod def square ( cls , size : float ): return cls ( width = size , height = size ) def area ( self ) -> float : return self . width * self . height rect = Rectangle . square ( 30 ) print ( f \"The area of the rectangle is { rect . area () } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) As we observe here we can now call the square method without Rectangle being instantiated. Summary Uisng Pydantic allows you to create meaningful data models for your domain that include run-time validation. This can enable your code to be clear.","title":"An Example Program using Pydantic"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/#an-example-program-using-pydantic","text":"To understand how we can leverage these data models, let's write a program that calculates the area of a rectangle. We'll start with variables and gradually refactor the program. We'll begin by creating a new project with Poetry called rectangles that will take the width and height of a rectangle specified in pixels and calculate the area. Filename: rectangles/__main__.py def area ( width : float , height : float ) -> float : return width * height width : float = 30 height : float = 50 print ( f \"The area of the rectange is { area ( width , height ) } square pixels.\" ) The area function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that\u2019s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together.","title":"An Example Program using Pydantic"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/#refactoring-with-pydantic-adding-more-meaning","text":"Filename: rectangles/__main__.py from pydantic import BaseModel class Rectangle ( BaseModel ): width : float height : float def area ( rect : Rectangle ) -> float : return rect . width * rect . height rect = Rectangle ( width = 30 , height = 50 ) print ( f \"The area of the rectangle is { area ( rect ) } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) Here we have defined a data class object named Rectangle , which has the width and height defined. We can further extend this example by changing area to be a method","title":"Refactoring with Pydantic: Adding more Meaning"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/#defining-methods-in-python","text":"Let's change the area function which has Rectangle instance as a parameter to be the area method as part of the Rectangle object itself. Filename: rectangles/__main__.py from pydantic import BaseModel class Rectangle ( BaseModel ): width : float height : float def area ( self ) -> float : return self . width * self . height rect = Rectangle ( width = 30 , height = 50 ) print ( f \"The area of the rectangle is { rect . area () } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) To define a method, we use whitespace indent a method which allows it to be associated to the Rectangle object. We accomplish this by moving the area function and change the signature to be self in the signature and everywhere else within the the area method. Then we can use the method syntax to call the area method on our Rectangle instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments. The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of self in every method\u2019s signature, is for organization. Next we can add further validation to the Rectangle object, which ensures width and height upon instantiation is always non-zero. Filename: rectangles/__main__.py from pydantic import BaseModel , validator class Rectangle ( BaseModel ): width : float height : float @validator ( 'width' , 'height' ) def check_positive_size ( cls , v ): if v <= 0 : raise ValueError ( \"Width and height of a rectange needs to be a positive number\" ) return v def area ( self ) -> float : return self . width * self . height rect = Rectangle ( width = 30 , height = 50 ) print ( f \"The area of the rectangle is { rect . area () } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) You can try changing width or height to be zero or less, which should then raise a ValueError , which demonstrates the runtime validation which is enabled as part of Pydantic.","title":"Defining methods in Python"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/#methods-with-parameters","text":"Let's implement an additional method to the Rectangle object, which takes another instance of Rectangle and returns True if the second Rectangle can fit completely within self ; otherwise it should return false . Filename: rectangles/__main__.py from pydantic import BaseModel , validator from typing import Any class Rectangle ( BaseModel ): width : float height : float @validator ( 'width' , 'height' ) def check_positive_size ( cls , v ): if v <= 0 : raise ValueError ( \"Width and height of a rectange needs to be a positive number\" ) return v def area ( self ) -> float : return self . width * self . height def can_hold ( self , rect : Any ) -> bool : return self . width > rect . width and self . height > rect . height rect = Rectangle ( width = 30 , height = 50 ) rect2 = Rectangle ( width = 20 , height = 40 ) print ( f \"Can rect hold rect2? { rect . can_hold ( rect2 ) } \" ) Unfortunately in the current versions of Python, type annotations won't work in the way we might expect. That is if the method signature resembles def can_hold ( self , rect : Rectangle ) -> bool : return self . width > rect . width and self . height > rect . height Python would complain, to somewhat resolve this I've replaced it with Any . It is possible with some refactoring to get around this issue, but it may sacrifice readability.","title":"Methods with Parameters"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/#using-classmethod","text":"Class method can be used if we wish to construct or use methods associated with the object itself. They can be used as a constructor. An example is if we wish to make it easier to create a square from Rectangle rather than specifying the same value twice Filename: rectanges/__main__.py from pydantic import BaseModel , validator class Rectangle ( BaseModel ): width : float height : float @validator ( 'width' , 'height' ) def check_positive_size ( cls , v ): if v <= 0 : raise ValueError ( \"Width and height of a rectange needs to be a positive number\" ) return v @classmethod def square ( cls , size : float ): return cls ( width = size , height = size ) def area ( self ) -> float : return self . width * self . height rect = Rectangle . square ( 30 ) print ( f \"The area of the rectangle is { rect . area () } square pixels.\" ) print ( f \"Our Rectangle is a data object defined with: \\n\\t Rectangle( { rect } )\" ) As we observe here we can now call the square method without Rectangle being instantiated.","title":"Using classmethod"},{"location":"4.%20Data%20Structures%20in%20Python/03-example/#summary","text":"Uisng Pydantic allows you to create meaningful data models for your domain that include run-time validation. This can enable your code to be clear.","title":"Summary"},{"location":"5.%20Managing%20Python%20Packages%20and%20Modules/01-python-packages/","text":"As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you\u2019ll clarify where to find code that implements a particular feature and where to go to change how a feature works. The programs we\u2019ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. In this chapter, we'll cover how to build a Python module, and how to manage package builds using Poetry.","title":"Managing Growing Projects with Packages and Modules"},{"location":"5.%20Managing%20Python%20Packages%20and%20Modules/02-defining-modules/","text":"Defining Modules in Python In this section, we'll talk about modules in Python, specifically the usage of the __init__.py file. Modules let us organize code within a package into groups for readability and easy reuse. As an example let's write a package that provides the functionality of a restaurant. We\u2019ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code. In the restaurant industry, some parts of a restaurant are referred to as front of house and others as back of house . Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work. To structure our crate in the same way that a real restaurant works, we can organize the functions into nested modules. Create a new library named restaurant by running poetry new restaurant , We can now create the front_of_house folder with hosting.py and serving.py , which should resemble the following: restaurant \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 front_of_house \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 hosting.py \u2514\u2500\u2500 serving.py This tree shows how the modules can nest inside one another, note that we require the __init__.py file to inform the location of a module. To test that this works, let's add some dummy functions to hosting.py and serving.py that resembles the below: Filename: restaurant/front_of_house/hosting.py def add_to_waitlist (): pass def seat_at_table (): pass Filename: restaurant/front_of_house/serving.py def take_order (): pass def serve_order (): pass def take_payment (): pass We can install our package by running poetry install $ poetry install Installing dependencies from lock file (..snip..) Installing the current project: restaurant (0.1.0) To demonstrate how we can interact with our package, we can spawn a new shell using poetry shell $ poetry shell Spawning shell within (..snip..) $ python >>> from restaurant.front_of_house.hosting import add_to_waitlist >>> exit() $ exit To exit the shell itself, simply use exit .","title":"Defining Modules in Python"},{"location":"5.%20Managing%20Python%20Packages%20and%20Modules/02-defining-modules/#defining-modules-in-python","text":"In this section, we'll talk about modules in Python, specifically the usage of the __init__.py file. Modules let us organize code within a package into groups for readability and easy reuse. As an example let's write a package that provides the functionality of a restaurant. We\u2019ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code. In the restaurant industry, some parts of a restaurant are referred to as front of house and others as back of house . Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work. To structure our crate in the same way that a real restaurant works, we can organize the functions into nested modules. Create a new library named restaurant by running poetry new restaurant , We can now create the front_of_house folder with hosting.py and serving.py , which should resemble the following: restaurant \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 front_of_house \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 hosting.py \u2514\u2500\u2500 serving.py This tree shows how the modules can nest inside one another, note that we require the __init__.py file to inform the location of a module. To test that this works, let's add some dummy functions to hosting.py and serving.py that resembles the below: Filename: restaurant/front_of_house/hosting.py def add_to_waitlist (): pass def seat_at_table (): pass Filename: restaurant/front_of_house/serving.py def take_order (): pass def serve_order (): pass def take_payment (): pass We can install our package by running poetry install $ poetry install Installing dependencies from lock file (..snip..) Installing the current project: restaurant (0.1.0) To demonstrate how we can interact with our package, we can spawn a new shell using poetry shell $ poetry shell Spawning shell within (..snip..) $ python >>> from restaurant.front_of_house.hosting import add_to_waitlist >>> exit() $ exit To exit the shell itself, simply use exit .","title":"Defining Modules in Python"}]}